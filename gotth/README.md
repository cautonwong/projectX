好的，我们已经有了一个非常清晰和宏伟的设计蓝图。现在，让我们把它分解成一个实际的、可操作的、循序渐进的实施计划。

这个计划将引导我们从当前已经完成的认证和基础 CRUD 功能，一步步地构建出我们最终设计的那个“教科书级别”的 Boilerplate。

---

### **Boilerplate v2.0 实施步骤计划**

#### **前提：当前状态**
我们已经完成了：
*   ✅ 项目环境搭建 (Go, Templ, HTMX, Tailwind, DaisyUI, Air, Makefile)。
*   ✅ 一个功能完整且体验良好的认证系统 (注册、登录、登出、受保护路由)。
*   ✅ 一个基础的 CRUD 应用范例 (待办事项列表)。
*   ✅ 一个专业的、响应式的侧边栏布局。

---

### **阶段一：代码重构与 “UI 实验室” 奠基 (预计耗时：2-3 小时)**
**目标：** 整理现有代码，为即将到来的大量组件示例建立一个清晰、可扩展的组织结构。

*   **步骤 1.1：重构 `view` 目录**
    *   在 `view/shared` 目录下创建新的子目录：`forms/`, `feedback/`, `ui/`。
    *   将现有的可复用组件移动到新的目录中：
        *   `view/shared/error_alert.templ` -> `view/shared/feedback/alert.templ`
        *   创建 `view/shared/forms/button.templ` 并将常见的按钮样式抽象进去。
        *   创建 `view/shared/ui/card.templ` 并将表单页面的卡片样式抽象出来。
    *   更新所有引用这些组件的 `.templ` 文件的 `import` 路径。

*   **步骤 1.2：创建 “UI 实验室” 基础**
    *   在 `view/ui_lab` 目录下创建 `index.templ`，这将是实验室的主页面。它应该包含一个清晰的导航，链接到各个组件的展示区。
    *   在 `internal/handler` 目录下创建 `ui_lab_handler.go`，编写一个 `HandleUILabShow` 方法来渲染 `index.templ`。
    *   在 `cmd/app/main.go` 的**受保护路由组**中，添加新路由 `r.Get("/ui-lab", uiLabHandler.HandleUILabShow)`。
    *   在 `app.templ` 的侧边栏中，添加入口链接到 `/ui-lab`。

*   **✅ 阶段一交付成果：**
    *   一个结构更清晰的 `view` 目录。
    *   一个可以访问的、但内容尚为空的 “UI 实验室” 页面。

---

### **阶段二：实现基础与反馈组件范例 (预计耗时：4-6 小时)**
**目标：** 在 “UI 实验室” 中填充最常见和最核心的组件，并展示 HTMX 与 Alpine.js 的正确分工。

*   **步骤 2.1：按钮与表单组件**
    *   在 `view/ui_lab` 中创建 `buttons_example.templ` 和 `forms_example.templ`。
    *   **按钮**: 展示所有样式和状态。特别要实现一个点击后会进入“加载中”状态的按钮，以此来教学 `htmx-indicator`。
    *   **表单**: 展示所有常见的输入类型、带错误提示的输入框、复选框、单选框等。

*   **步骤 2.2：模态框 (Modal)**
    *   在 `view/shared/feedback` 创建 `modal.templ`。
    *   在 “UI 实验室” 中创建一个按钮，点击后使用 **Alpine.js** (`x-data`, `@click`) 来打开一个模态框。
    *   **进阶示例**: 再创建一个按钮，点击后使用 `hx-get` 从服务器获取一段内容，并将其注入到已经打开的模态框中，以此教学 HTMX 与 Alpine.js 的协同工作。

*   **步骤 2.3：通知/吐司 (Toast)**
    *   在 `view/shared/feedback` 创建 `toast.templ`。
    *   在 `base.templ` 的布局中，添加一个 **Alpine.js** 组件作为“Toast 容器”，它能管理一个 Toast 消息队列，并能监听自定义事件。
    *   在 “UI 实验室” 中创建一个表单，其 `handler` 在成功处理后，会在响应头中返回 `HX-Trigger: 'showToast', '{"message": "操作成功!", "type": "success"}'`。
    *   验证 Toast 是否能被 Alpine.js 正确捕获并显示。

*   **✅ 阶段二交付成果：**
    *   一个内容丰富的 “UI 实验室”，包含按钮、表单、模态框和通知的完整、可交互的范例。
    *   开发者可以通过这些范例，清晰地理解何时使用 HTMX，何时使用 Alpine.js，以及如何让后端驱动前端的反馈。

---

### **阶段三：构建高级表格组件 (预计耗时：6-8 小时)**
**目标：** 这是 Boilerplate 的核心教学部分。构建一个功能完备的表格，将所有高级 HTMX 模式融会贯通。

*   **步骤 3.1：基础表格与分页**
    *   创建 `view/shared/ui/table.templ` 和相关的处理器。
    *   使用模拟数据，实现表格的服务端分页功能 (`hx-get`, `hx-target`, `hx-push-url`)。

*   **步骤 3.2：添加排序与过滤**
    *   让列表头可点击，实现服务端排序。
    *   在表格上方添加搜索框和下拉筛选器，实现实时搜索 (`hx-trigger="keyup changed delay:500ms"`) 和筛选。

*   **步骤 3.3：实现行动作 (行内编辑与删除)**
    *   为每一行添加“编辑”和“删除”按钮。
    *   实现“删除”功能 (`hx-delete`)。
    *   实现“行内编辑”功能，点击“编辑”后将该行 `<tr>` 替换为一个可编辑的表单 `<tr>` (`hx-get` + `hx-swap="outerHTML"`)。

*   **步骤 3.4 (可选进阶)：批量操作**
    *   为每一行添加复选框，并实现批量删除功能 (`hx-post`, `hx-include`)。
    *   使用 Alpine.js 控制“批量操作”按钮的显示/隐藏。

*   **✅ 阶段三交付成果：**
    *   一个功能极其强大的表格组件范例，它本身就是一个小型的、完整的 Web 应用。
    *   这是 Boilerplate 最具说服力的“杀手级功能”，展示了该技术栈的巨大潜力。

---

### **阶段四：为特定领域预热 (预计耗时：3-4 小时)**
**目标：** 在 Boilerplate 中内置一些高级模式，为开发者构建更复杂的应用（如物联网、电商）提供起点。

*   **步骤 4.1：实现 SSE 实时更新**
    *   在 Go 后端创建一个简单的 SSE 广播器服务。
    *   创建一个 `/sse-demo` 页面，展示一个从服务器实时接收更新的数字或时钟。
    *   教学 `htmx-sse` 扩展的用法。

*   **步骤 4.2：实现多步骤表单**
    *   创建一个 `/multi-step-form` 页面。
    *   设计一个分步的用户信息收集表单，后端使用 Session 来暂存每一步的数据。
    *   展示如何通过 HTMX 在不同步骤的表单片段之间无缝切换。

*   **✅ 阶段四交付成果：**
    *   为需要实时数据和复杂工作流的应用提供了清晰、可行的实现范例。

---

### **阶段五：最终文档与清理 (持续进行)**
**目标：** 确保 Boilerplate 易于理解、易于使用。

*   **步骤 5.1：编写 `README.md`**
    *   详细阐述项目的核心理念、技术选型、以及如何启动。
    *   为 “UI 实验室” 中的每一个范例，都撰写一小段文字，解释它所要教学的核心模式和关键代码。

*   **步骤 5.2：代码注释**
    *   在代码的关键部分（例如，中间件、复杂的 HTMX 属性、Alpine.js 组件）添加清晰的注释，解释“为什么”这么做。

*   **✅ 最终交付成果：**
    *   一个代码精良、文档清晰、高度自解释的、教科书级别的 Go 全栈项目样板。